---
title: "Functions"
format: html
editor: visual
---

## Data Processing

Writing a function to input an API Url and then review it in our workspace. The timeout was increased to allow for the heavier burdens that come with loading the large datasets with the later functions on this page.

```{r}
library(tidyverse)
library(httr)
usual_process <- function(URL) {
  id <- GET(URL, httr::timeout(60))
  return(id)
}
```

Writing a function to take in the output of returned by GET() and create a tibble from it, assigning column names relevant to the data of interest.

```{r}
library(jsonlite)
helper <- function(id) {
  parsed_stats <- fromJSON(rawToChar(id$content))
  tibble <- as_tibble(parsed_stats)
  colnames(tibble) <- tibble[1,]
  tibble <- tibble[-1,]
  return(tibble)
}
```

Writing a function to query the Census API and also allow several variables to be specified within.

```{r}
#setting up function with default arguments
census <- function(year = 2022, num_var = c("AGEP", "PWGTP"), cat_var = "SEX", geog = "state", spec = "20") {
  
  #checking for valid year
  if(!(year %in% c(2010:2022))) {
    stop("Error: year not valid")
  } 
  
  #describing valid numeric variables
  num_valid <- c("AGEP", "GASP", "GRPIP", "JWAP", "JWDP", "JWMNP", "PWGTP")
  
  #ensuring the PWGTP is always returned
  num_var <- unique(c(num_var, "PWGTP"))
  
  #checking for valid numeric variables, then cleaning it up to be easily added to url
  if(any(!(num_var %in% num_valid))) {
    stop("Error: num_var not valid")
  }
  num_var <- paste(num_var, collapse = ",")
  
  #describing valid categorical variables
  cat_valid <- c("FER", "HHL", "HISPEED", "JWTRNS", "SCH", "SCHL", "SEX")
  
  #checking for valid categorical variables
  if(any(!(cat_var %in% cat_valid))) {
    stop("Error: cat_var not valid")
  }
  
  #ensuring at least one catvar is returned, then cleaning variable up to be easily added to url
  if(length(cat_var) == 0) {
    stop("Error: at least one cat_var must be specified")
  }
  cat_var <- paste(cat_var, collapse = ",")
  
  #checking for valid geographical levels & subsets depending on level selected, includes all of the given geography level if no subset is specified
  spec_valid <- list(region = 1:4, division = 1:9, state = 1:56)
  if(is.null(spec)) {
     
  }
    else {
      if(!geog %in% names(spec_valid)) {
    stop("Error: invalid geog")
  }
  if(!spec %in% spec_valid[[geog]]) {
    stop("Error: invalid spec for geog selected")
  }
    }
  
  #creating url from various arguments for census api
  url <- paste0("https://api.census.gov/data/", as.character(year), "/acs/acs1/pums?get=", num_var, ",", cat_var, "&for=", geog)
  if(length(spec) != 0) {
    url <- paste0(url, ":", spec)
  }
  
  #GET function from first problem
  id <- usual_process(url)
  
  #helper function from second problem to create tibble 
  tibble <- helper(id)
  
  #writing a new function to parse out the number code  for time columns into a midpoint time value. the function relies on the fact that the midpoints of each number code: (0-285) start at 00:002 and count up by intervals of 5 minutes.
 convert_time <- function(x) {
   time_cols <- c("JWAP", "JWDP")
   for(col in time_cols) {
     if(col %in% names(x)) {
       numeric_col <- as.numeric(x[[col]])
       x[[col]] <- ifelse(numeric_col == 0, as.POSIXct(NA), as.POSIXct("00:02", format = "%H:%M") + (numeric_col-1) * 300)
       class(x[[col]]) <- c("POSIXct", "POSIXt")
     }
   }
   return(x)
 }

  #converts JWAP and JWDP code numbers to midpoint time, other variables in num_var to numeric
  tibble <- tibble |> convert_time()
  
  tibble <- tibble |> mutate(across(any_of(c("AGEP", "GASP", "GRPIP", "JWMNP", "PWGTP")), as.numeric))
  
  class(tibble) <- c("census", class(tibble))

  return(tibble)
}
```

Writing a function that allows a user to specify all the parameters above as well as multiple years through looping the single year function above.

```{r}
#Setting up the function with same arguments from above, but with the addition of the years variable.
census_year_range <- function(years, num_var = c("AGEP", "PWGTP"), cat_var = "SEX", geog = "state", spec = "20") {
  
  #creating a list to store results
  output <- list()
  
  #for loop to apply the census function to each year of interest, as well as transferring the arguments of census_year_range to the arguments of the census function
  for(x in years) {
    output[[as.character(x)]] <- census(year = x, num_var = num_var, cat_var = cat_var, geog = geog, spec = spec)
  }
  
  #binding the tibbles together with a years column
  bind_rows(output, .id = "years")
}   
```

## Summary Functions/Plots

Creating the census summary function that will produce means and standard deviations for numeric variables as well as counts for categorical variables.

```{r}

#Calling data for function
mydata <- census()
glimpse(mydata)

summary.function <- function(mydata, num_var = NULL, cat_var = NULL, na.rm = TRUE, ...){
  #Checking for census class
  if (!"census" %in% class(mydata)) {
    stop("Error: Does not have census class")
  }
  
  #Checking that PWGTP exists and is numeric
  if (!("PWGTP" %in% names(mydata)) || !is.numeric(mydata$PWGTP)) {
    stop("Error: PWGTP is either missing or not numeric")
  }
  
  #Creating weight vector
  weight_vector <- mydata$PWGTP
  
  #Defining numeric variable (user-selection)
  if (is.null(num_var)) {
    
    #Default (all numeric colums besides PWGTP)
    num_vars <- names(dplyr::select(mydata, where(is.numeric)))
    num_vars <- num_vars[num_vars != "PWGTP"]
    
    if (length(num_vars) == 0) {
      stop("Error: NOT a numeric variable")
    }
    
  } else {
  
    #Numeric Variables specificed by user 
    
    #If the variables are not found
    if (!all(num_var %in% names(mydata))) {
      stop("Error: 1 or more user-provided numeric variables were NOT found")
    }
    
    #If the variables are not numeric
    if (!all(sapply(mydata[num_var], is.numeric))) {
      stop("Error: 1 or more user-provided variables is NOT numeric")
    }
    
    #If the input makes it  all the above checks then use
    num_vars <- num_var
  }
  
  #Defining categorical variables (user-selection)
  if (is.null(cat_var)) {
    cat_vars <- names(dplyr::select(mydata, where(is.character)))
    
    if (length(cat_vars) == 0) {
      stop("Error: NOT a character variable")
    }
    
  } else {
    
    #Categorical variables specified by user
    
    #If categorical variables are not found
    if (!all(cat_var %in% names(mydata))) {
      stop("Error: 1 or more user-provided categorical variables were NOT found")
    }
    #If variables are not character
    if (!all(sapply(mydata[cat_var], is.character))) {
      stop("Error: 1 or more user-provided categorical variables is NOT character")
    }
    #If the input makes it  all the above checks then use
    cat_vars <- cat_var
  }
  
  #Summary function definiton (A. Numeric Summaries B. Categorical Summaries)
  
  #Creating the Numeric Summary Table to hold the results
  num_stats <- data.frame(
    variable = character(),
    weighted_mean = numeric(),
    weighted_sd = numeric(),
    stringsAsFactors = FALSE
    )
  #Going through individual numeric variables
  for (var in num_vars) {
    numeric_vector <- mydata[[var]]
    
    #Formulas
    sample_mean <- sum(numeric_vector * weight_vector)/ sum(weight_vector)
    sample_sd <- sqrt(sum(numeric_vector^2 * weight_vector) / sum(weight_vector)-sample_mean^2)
    
    #Adding row to the result table
    num_stats <- rbind(
      num_stats,
      data.frame(
        variable = var,
        weighted_mean = sample_mean,
        weighted_sd = sample_sd,
        stringsAsFactors = FALSE
      )
    )
  }
   #Creating the Categorical Summary Table to hold the results
  cat_stats <- data.frame(
    variable = character(),
    level = character(),
    weighted_count = numeric(),
    stringsAsFactors = FALSE
  )
  #Going through individual categorical variables
  for (var in cat_vars) {
    cat_tibble <- mydata[[var]]
    
    #Weighted Counts
    w_counts <- tapply(weight_vector, cat_tibble, sum, na.rm = TRUE)
    
    #Making it a data frame 
    cat_df <- data.frame(
      variable = var,
      level = names(w_counts),
      weighted_count = as.numeric(w_counts),
      stringsAsFactors = FALSE
    )
    #Adding the rows to the result table
    cat_stats <- rbind(cat_stats, cat_df)
    
  }
  
  #Returning Results 
  return(list(numeric = num_stats, categorical = cat_stats))
  
}

```

Testing the summary function on a variable returned from the census API function.

```{r}
#Testing the summary function
summary.function(mydata)


```

---
title: "Functions"
format: html
editor: visual
---

## Data Processing
Writing a function to input an API Url and then review it in our workspace.
```{r}
library(tidyverse)
library(httr)
usual_process <- function(URL) {
  id <- GET(URL)
  return(id)
}
```

Writing a function to take in the output of returned by GET() and create a tibble from it, assigning column names relevant to the data of interest.
```{r}
library(jsonlite)
helper <- function(id) {
  parsed_stats <- fromJSON(rawToChar(id$content))
  tibble <- as_tibble(parsed_stats)
  colnames(tibble) <- tibble[1,]
  tibble <- tibble[-1,]
  return(tibble)
}
```
Writing a function to query the Census API and also allow several variables to be specified within.
```{r}
#setting up function with default arguments
census <- function(year = 2022, num_var = c("AGEP", "PWGTP"), cat_var = "SEX", geog = "state", spec = "20") {
  
  #checking for valid year
  if(!(year %in% c(2010:2022))) {
    stop("Error: year not valid")
  } 
  
  #describing valid numeric variables
  num_valid <- c("AGEP", "GASP", "GRPIP", "JWAP", "JWDP", "JWMNP", "PWGTP")
  
  #ensuring the PWGTP is always returned
  num_var <- unique(c(num_var, "PWGTP"))
  
  #checking for valid numeric variables, then cleaning it up to be easily added to url
  if(any(!(num_var %in% num_valid))) {
    stop("Error: num_var not valid")
  }
  num_var <- paste(num_var, collapse = ",")
  
  #describing valid categorical variables
  cat_valid <- c("FER", "HHL", "HISPEED", "JWTRNS", "SCH", "SCHL", "SEX")
  
  #checking for valid categorical variables
  if(any(!(cat_var %in% cat_valid))) {
    stop("Error: cat_var not valid")
  }
  
  #ensuring at least one catvar is returned, then cleaning variable up to be easily added to url
  if(length(cat_var) == 0) {
    stop("Error: at least one cat_var must be specified")
  }
  cat_var <- paste(cat_var, collapse = ",")
  
  #checking for valid geographical levels & subsets depending on level selected, includes all of the given geography level if no subset is specified
  spec_valid <- list(region = 1:4, division = 1:9, state = 1:56)
  if(is.null(spec)) {
     
  }
    else {
      if(!geog %in% names(spec_valid)) {
    stop("Error: invalid geog")
  }
  if(!spec %in% spec_valid[[geog]]) {
    stop("Error: invalid spec for geog selected")
  }
    }
  
  #creating url from various arguments for census api
  url <- paste0("https://api.census.gov/data/", as.character(year), "/acs/acs1/pums?get=", num_var, ",", cat_var, "&for=", geog)
  if(length(spec) != 0) {
    url <- paste0(url, ":", spec)
  }
  
  #GET function from first problem
  id <- usual_process(url)
  
  #helper function from second problem to create tibble 
  tibble <- helper(id)
  
  #writing a new function to parse out the number code  for time columns into a midpoint time value. the function relies on the fact that the midpoints of each number code: (0-285) start at 00:002 and count up by intervals of 5 minutes.
 convert_time <- function(x) {
   time_cols <- c("JWAP", "JWDP")
   for(col in time_cols) {
     if(col %in% names(x)) {
       numeric_col <- as.numeric(x[[col]])
       x[[col]] <- ifelse(numeric_col == 0, as.POSIXct(NA), as.POSIXct("00:02", format = "%H:%M") + (numeric_col-1) * 300)
       class(x[[col]]) <- c("POSIXct", "POSIXt")
     }
   }
   return(x)
 }

  #converts JWAP and JWDP code numbers to midpoint time, other variables in num_var to numeric
  tibble <- tibble |> convert_time()
  
  tibble <- tibble |> mutate(across(any_of(c("AGEP", "GASP", "GRPIP", "JWMNP", "PWGTP")), as.numeric))

  return(tibble)
}
```

Writing a function that allows a user to specify all the parameters above as well as multiple years through looping the single year function above.
```{r}
#Setting up the function with same arguments from above, but with the addition of the years variable.
census_year_range <- function(years, num_var = c("AGEP", "PWGTP"), cat_var = "SEX", geog = "state", spec = "20") {
  
  #creating a list to store results
  output <- list()
  
  #for loop to apply the census function to each year of interest, as well as transferring the arguments of census_year_range to the arguments of the census function
  for(x in years) {
    output[[as.character(x)]] <- census(year = x, num_var = num_var, cat_var = cat_var, geog = geog, spec = spec)
  }
  
  #binding the tibbles together with a years column
  bind_rows(output, .id = "years")
}   
```

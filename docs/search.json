[
  {
    "objectID": "Narrative & Examples.html",
    "href": "Narrative & Examples.html",
    "title": "Project 1: Narrative & Examples",
    "section": "",
    "text": "This chunk below allows functions created on the function code qmd file to be recognized when called on this file for the final webpage rendering."
  },
  {
    "objectID": "Narrative & Examples.html#data-processing",
    "href": "Narrative & Examples.html#data-processing",
    "title": "Project 1: Narrative & Examples",
    "section": "Data Processing",
    "text": "Data Processing\nWriting a function to input an API Url and then review it in our workspace. The timeout was increased to allow for the heavier burdens that come with loading the large datasets with the later functions on this page.\n\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   4.0.0     ✔ tibble    3.3.0\n✔ lubridate 1.9.4     ✔ tidyr     1.3.1\n✔ purrr     1.1.0     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\nlibrary(httr)\n\nusual_process &lt;- function(URL) {\n  id &lt;- GET(URL, httr::timeout(60))\n  return(id)\n}\n\nWriting a function to take in the output of returned by GET() and create a tibble from it, assigning column names relevant to the data of interest.\n\nlibrary(jsonlite)\n\n\nAttaching package: 'jsonlite'\n\n\nThe following object is masked from 'package:purrr':\n\n    flatten\n\nhelper &lt;- function(id) {\n  parsed_stats &lt;- fromJSON(rawToChar(id$content))\n  tibble &lt;- as_tibble(parsed_stats)\n  colnames(tibble) &lt;- tibble[1,]\n  tibble &lt;- tibble[-1,]\n  return(tibble)\n}\n\nWriting a function to query the Census API and also allow several variables to be specified within.\n\n#setting up function with default arguments\ncensus &lt;- function(year = 2022, num_var = c(\"AGEP\", \"PWGTP\"), cat_var = \"SEX\", geog = \"state\", spec = \"20\") {\n  \n  #checking for valid year\n  if(!(year %in% c(2010:2022))) {\n    stop(\"Error: year not valid\")\n  } \n  \n  #describing valid numeric variables\n  num_valid &lt;- c(\"AGEP\", \"GASP\", \"GRPIP\", \"JWAP\", \"JWDP\", \"JWMNP\", \"PWGTP\")\n  \n  #ensuring the PWGTP is always returned\n  num_var &lt;- unique(c(num_var, \"PWGTP\"))\n  \n  #checking for valid numeric variables, then cleaning it up to be easily added to url\n  if(any(!(num_var %in% num_valid))) {\n    stop(\"Error: num_var not valid\")\n  }\n  num_var &lt;- paste(num_var, collapse = \",\")\n  \n  #describing valid categorical variables\n  cat_valid &lt;- c(\"FER\", \"HHL\", \"HISPEED\", \"JWTRNS\", \"SCH\", \"SCHL\", \"SEX\")\n  \n  #checking for valid categorical variables\n  if(any(!(cat_var %in% cat_valid))) {\n    stop(\"Error: cat_var not valid\")\n  }\n  \n  #ensuring at least one catvar is returned, then cleaning variable up to be easily added to url\n  if(length(cat_var) == 0) {\n    stop(\"Error: at least one cat_var must be specified\")\n  }\n  cat_var &lt;- paste(cat_var, collapse = \",\")\n  \n  #checking for valid geographical levels & subsets depending on level selected, includes all of the given geography level if no subset is specified\n  spec_valid &lt;- list(region = 1:4, division = 1:9, state = 1:56)\n  if(is.null(spec)) {\n     \n  }\n    else {\n      if(!geog %in% names(spec_valid)) {\n    stop(\"Error: invalid geog\")\n  }\n  if(!spec %in% spec_valid[[geog]]) {\n    stop(\"Error: invalid spec for geog selected\")\n  }\n    }\n  \n  #creating url from various arguments for census api\n  url &lt;- paste0(\"https://api.census.gov/data/\", as.character(year), \"/acs/acs1/pums?get=\", num_var, \",\", cat_var, \"&for=\", geog)\n  if(length(spec) != 0) {\n    url &lt;- paste0(url, \":\", spec)\n  }\n  \n  #GET function from first problem\n  id &lt;- usual_process(url)\n  \n  #helper function from second problem to create tibble \n  tibble &lt;- helper(id)\n  \n  #writing a new function to parse out the number code  for time columns into a midpoint time value. the function relies on the fact that the midpoints of each number code: (0-285) start at 00:002 and count up by intervals of 5 minutes.\n convert_time &lt;- function(x) {\n   time_cols &lt;- c(\"JWAP\", \"JWDP\")\n   for(col in time_cols) {\n     if(col %in% names(x)) {\n       numeric_col &lt;- as.numeric(x[[col]])\n       x[[col]] &lt;- ifelse(numeric_col == 0, as.POSIXct(NA), as.POSIXct(\"00:02\", format = \"%H:%M\") + (numeric_col-1) * 300)\n       class(x[[col]]) &lt;- c(\"POSIXct\", \"POSIXt\")\n     }\n   }\n   return(x)\n }\n\n  #converts JWAP and JWDP code numbers to midpoint time, other variables in num_var to numeric\n  tibble &lt;- tibble |&gt; convert_time()\n  \n  tibble &lt;- tibble |&gt; mutate(across(any_of(c(\"AGEP\", \"GASP\", \"GRPIP\", \"JWMNP\", \"PWGTP\")), as.numeric))\n  \n  class(tibble) &lt;- c(\"census\", class(tibble))\n\n  return(tibble)\n}\n\nWriting a function that allows a user to specify all the parameters above as well as multiple years through looping the single year function above.\n\n#Setting up the function with same arguments from above, but with the addition of the years variable.\ncensus_year_range &lt;- function(years, num_var = c(\"AGEP\", \"PWGTP\"), cat_var = \"SEX\", geog = \"state\", spec = \"20\") {\n  \n  #creating a list to store results\n  output &lt;- list()\n  \n  #for loop to apply the census function to each year of interest, as well as transferring the arguments of census_year_range to the arguments of the census function\n  for(x in years) {\n    output[[as.character(x)]] &lt;- census(year = x, num_var = num_var, cat_var = cat_var, geog = geog, spec = spec)\n  }\n  \n  #binding the tibbles together with a years column\n  bind_rows(output, .id = \"years\")\n}"
  },
  {
    "objectID": "Narrative & Examples.html#summary-functionsplots",
    "href": "Narrative & Examples.html#summary-functionsplots",
    "title": "Project 1: Narrative & Examples",
    "section": "Summary Functions/Plots",
    "text": "Summary Functions/Plots\nCreating the census summary function that will produce means and standard deviations for numeric variables as well as counts for categorical variables.\n\n#Calling data for function\ncensus_data &lt;- census()\n\nWarning: The `x` argument of `as_tibble.matrix()` must have unique column names if\n`.name_repair` is omitted as of tibble 2.0.0.\nℹ Using compatibility `.name_repair`.\n\nsummary.census &lt;- function(census_data, num_var = NULL, cat_var = NULL, na.rm = TRUE, ...){\n  #Checking for census class\n  if (!\"census\" %in% class(census_data)) {\n    stop(\"Error: Does not have census class\")\n  }\n  \n  #Checking that PWGTP exists and is numeric\n  if (!(\"PWGTP\" %in% names(census_data)) || !is.numeric(census_data$PWGTP)) {\n    stop(\"Error: PWGTP is either missing or not numeric\")\n  }\n  \n  #Creating weight vector\n  weight_vector &lt;- census_data$PWGTP\n  \n  #Defining numeric variable (user-selection)\n  if (is.null(num_var)) {\n    \n    #Default (all numeric colums besides PWGTP)\n    num_vars &lt;- names(dplyr::select(census_data, where(is.numeric)))\n    num_vars &lt;- num_vars[num_vars != \"PWGTP\"]\n    \n    if (length(num_vars) == 0) {\n      stop(\"Error: NOT a numeric variable\")\n    }\n    \n  } else {\n  \n    #Numeric Variables specificed by user \n    \n    #If the variables are not found\n    if (!all(num_var %in% names(census_data))) {\n      stop(\"Error: 1 or more user-provided numeric variables were NOT found\")\n    }\n    \n    #If the variables are not numeric\n    if (!all(sapply(census_data[num_var], is.numeric))) {\n      stop(\"Error: 1 or more user-provided variables is NOT numeric\")\n    }\n    \n    #If the input makes it  all the above checks then use\n    num_vars &lt;- num_var\n  }\n  \n  #Defining categorical variables (user-selection)\n  if (is.null(cat_var)) {\n    cat_vars &lt;- names(dplyr::select(census_data, where(is.character)))\n    \n    if (length(cat_vars) == 0) {\n      stop(\"Error: NOT a character variable\")\n    }\n    \n  } else {\n    \n    #Categorical variables specified by user\n    \n    #If categorical variables are not found\n    if (!all(cat_var %in% names(census_data))) {\n      stop(\"Error: 1 or more user-provided categorical variables were NOT found\")\n    }\n    #If variables are not character\n    if (!all(sapply(census_data[cat_var], is.character))) {\n      stop(\"Error: 1 or more user-provided categorical variables is NOT character\")\n    }\n    #If the input makes it  all the above checks then use\n    cat_vars &lt;- cat_var\n  }\n  \n  #Summary function definiton (A. Numeric Summaries B. Categorical Summaries)\n  \n  #Creating the Numeric Summary Table to hold the results\n  num_stats &lt;- data.frame(\n    variable = character(),\n    weighted_mean = numeric(),\n    weighted_sd = numeric(),\n    stringsAsFactors = FALSE\n    )\n  #Going through individual numeric variables\n  for (var in num_vars) {\n    numeric_vector &lt;- census_data[[var]]\n    \n    #Formulas\n    sample_mean &lt;- sum(numeric_vector * weight_vector)/ sum(weight_vector)\n    sample_sd &lt;- sqrt(sum(numeric_vector^2 * weight_vector) / sum(weight_vector)-sample_mean^2)\n    \n    #Adding row to the result table\n    num_stats &lt;- rbind(\n      num_stats,\n      data.frame(\n        variable = var,\n        weighted_mean = sample_mean,\n        weighted_sd = sample_sd,\n        stringsAsFactors = FALSE\n      )\n    )\n  }\n   #Creating the Categorical Summary Table to hold the results\n  cat_stats &lt;- data.frame(\n    variable = character(),\n    level = character(),\n    weighted_count = numeric(),\n    stringsAsFactors = FALSE\n  )\n  #Going through individual categorical variables\n  for (var in cat_vars) {\n    cat_tibble &lt;- census_data[[var]]\n    \n    #Weighted Counts\n    w_counts &lt;- tapply(weight_vector, cat_tibble, sum, na.rm = TRUE)\n    \n    #Making it a data frame \n    cat_df &lt;- data.frame(\n      variable = var,\n      level = names(w_counts),\n      weighted_count = as.numeric(w_counts),\n      stringsAsFactors = FALSE\n    )\n    #Adding the rows to the result table\n    cat_stats &lt;- rbind(cat_stats, cat_df)\n    \n  }\n  \n  #Returning Results \n  return(list(numeric = num_stats, categorical = cat_stats))\n  \n}\n\nTesting the summary function on a variable returned from the census API function.\n\n#Testing the summary function\nsummary.census(census_data)\n\n$numeric\n  variable weighted_mean weighted_sd\n1     AGEP      38.69239    23.57071\n\n$categorical\n  variable level weighted_count\n1      SEX     1        1470818\n2      SEX     2        1466332\n3    state    20        2937150\n\n\nCreating a generic plot function to visualize data in census tibbles.\n\n#Plot function\nplot &lt;- function(census_data, cat_var, num_var, ...) {\n  #Check that census_data is a census tibble\n  if (!\"census\" %in% class(census_data)) {\n    stop(\"Error: Object is not part of the census class\")\n  }\n  \n  #Checking variable existance\n  if (!cat_var %in% names(census_data)) {\n    stop(\"Error: Categorical variable not found\")\n  }\n  \n  if (!num_var %in% names(census_data)) {\n    stop(\"Error: Numeric variable not found\")\n  }\n\n#Making the boxplot\nlibrary(ggplot2)\nggplot(census_data,\n       aes(x = get(cat_var), y = get(num_var), weight = PWGTP)) + geom_boxplot() + xlab(\"SEX\") + ylab (\"AGEP\")\n}\n\nplot(census_data, \"SEX\", \"AGEP\")"
  },
  {
    "objectID": "Narrative & Examples.html#data-processing-1",
    "href": "Narrative & Examples.html#data-processing-1",
    "title": "Project 1: Narrative & Examples",
    "section": "Data Processing",
    "text": "Data Processing\nThe purpose of all of the code that is included in this narrative section is to highlight examples of and to utilize functions created in the Function Code.qmd file of this project to both query the US Census API, as well as output the information contained within into a convenient tibble format, while allowing the user to specify several endpoints of interest within the requested region/geographical subset. We start by importing all of the necessary packages for these functions, then creating a function that takes any general URL (In this example the URL for the 2022 Census Microdata API from Census.gov) and then outputting the result of the GET() function as our URL_id object. This function will be utilized within future functions to quickly transform the URL that has been built to the user’s specifications. After looking at its structure we can see that the raw data is in the content element.\n\nlibrary(tidyverse)\nlibrary(httr)\nlibrary(jsonlite)\n\nURL_id &lt;- usual_process(\"https://api.census.gov/data/2022/acs/acs1/pums?get=SEX,PWGTP,MAR&SCHL=24\")\nURL_id\n\nResponse [https://api.census.gov/data/2022/acs/acs1/pums?get=SEX,PWGTP,MAR&SCHL=24]\n  Date: 2025-10-01 20:54\n  Status: 200\n  Content-Type: application/json;charset=utf-8\n  Size: 938 kB\n[[\"SEX\",\"PWGTP\",\"MAR\",\"SCHL\"],\n[\"2\",\"6\",\"5\",\"24\"],\n[\"2\",\"23\",\"2\",\"24\"],\n[\"1\",\"23\",\"3\",\"24\"],\n[\"1\",\"80\",\"5\",\"24\"],\n[\"1\",\"16\",\"1\",\"24\"],\n[\"1\",\"107\",\"3\",\"24\"],\n[\"2\",\"10\",\"5\",\"24\"],\n[\"1\",\"22\",\"1\",\"24\"],\n[\"2\",\"127\",\"5\",\"24\"],\n...\n\nstr(URL_id, max.level = 1)\n\nList of 10\n $ url        : chr \"https://api.census.gov/data/2022/acs/acs1/pums?get=SEX,PWGTP,MAR&SCHL=24\"\n $ status_code: int 200\n $ headers    :List of 11\n  ..- attr(*, \"class\")= chr [1:2] \"insensitive\" \"list\"\n $ all_headers:List of 1\n $ cookies    :'data.frame':    1 obs. of  7 variables:\n $ content    : raw [1:937508] 5b 5b 22 53 ...\n $ date       : POSIXct[1:1], format: \"2025-10-01 20:54:33\"\n $ times      : Named num [1:6] 0 0 0 0.000149 0.234229 ...\n  ..- attr(*, \"names\")= chr [1:6] \"redirect\" \"namelookup\" \"connect\" \"pretransfer\" ...\n $ request    :List of 7\n  ..- attr(*, \"class\")= chr \"request\"\n $ handle     :Class 'curl_handle' &lt;externalptr&gt; \n - attr(*, \"class\")= chr \"response\"\n\n\nNext, we take the output of the GET() function (same output as function above) and turn it into a tibble by creating and using a helper function. This function both creates a tibble as well as assigns names that correspond to the requested data. This function was also used within future functions to quickly return the data in the tibble format, from which various edits on the data type in each column can be performed.\n\nCensus_2022 &lt;- helper(URL_id) \nCensus_2022\n\n# A tibble: 44,079 × 4\n   SEX   PWGTP MAR   SCHL \n   &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;\n 1 2     6     5     24   \n 2 2     23    2     24   \n 3 1     23    3     24   \n 4 1     80    5     24   \n 5 1     16    1     24   \n 6 1     107   3     24   \n 7 2     10    5     24   \n 8 1     22    1     24   \n 9 2     127   5     24   \n10 2     46    5     24   \n# ℹ 44,069 more rows\n\n\nThe census() function will build a URL based on variables specified within the function and then query the API and output the requested data as a neat tibble with appropriate data types. The following example highlights the data type coercion built into this function. For example, the time column JWAP has many NA values of JWAP because the JWAP variable (time of arrival for work) value in the API is a number code, in which 0 corresponds to either unemployed individuals or someone who is working from home, so a time of arrival for work is not applicable in this case. To help prevent excess burden on loading data, a geographical subset was added and assigned to state 20, which is the census code for the state of Kansas.\n\ncensus(num_var = c(\"AGEP\", \"JWAP\"))\n\n# A tibble: 29,940 × 5\n    AGEP JWAP                PWGTP SEX   state\n   &lt;dbl&gt; &lt;dttm&gt;              &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;\n 1    17 2025-10-01 06:47:00     3 2     20   \n 2    17 NA                     12 1     20   \n 3    21 NA                     73 2     20   \n 4    22 2025-10-01 05:37:00    44 1     20   \n 5    67 NA                     58 2     20   \n 6    75 NA                      9 1     20   \n 7    19 NA                     53 1     20   \n 8    18 NA                      3 1     20   \n 9    64 NA                    133 1     20   \n10    19 NA                    102 2     20   \n# ℹ 29,930 more rows\n\n\nIf we want to look at a range of years, the census_year_range function calls the census function once for each year of interest, then merges these tibbles into one with a year variable. Every year within the range of valid years for the census function applies, except 2020 as there is no census API for that year. In this example we chose the years 2022, which is the default year call in census, plus the year 2021. The resulting tibble is considerably larger (58,897 rows vs 28,957 rows) than the previous example of the use of the census function due to the inclusion of two years of data.\n\ncensus_year_range(years = (c(2021, 2022)))\n\n# A tibble: 58,897 × 5\n   years  AGEP PWGTP SEX   state\n   &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;\n 1 2021     24    67 1     20   \n 2 2021     71   118 1     20   \n 3 2021     22   103 1     20   \n 4 2021     18   100 2     20   \n 5 2021     79    13 2     20   \n 6 2021     49    10 1     20   \n 7 2021     88    12 2     20   \n 8 2021     94     7 2     20   \n 9 2021     74    97 1     20   \n10 2021     27    78 1     20   \n# ℹ 58,887 more rows"
  },
  {
    "objectID": "Narrative & Examples.html#investigation-using-the-created-functions",
    "href": "Narrative & Examples.html#investigation-using-the-created-functions",
    "title": "Project 1: Narrative & Examples",
    "section": "Investigation Using the Created Functions",
    "text": "Investigation Using the Created Functions\nThe purpose of this section is show how the summary function and plot function defined in the Function Code.qmd file can be used to generate weighted summaries as well as a generic boxplot from the census() tibble created from the API above. We are able to grab data from the census api, run weighted summaries (means and standard deviations) using PWGTP, and from that we are able to make a simple weighted boxplot.The focus will start off with talking about the code whilst the end will discuss what we discovered when looking at the AGEP (age) and SEX(1: Male, 2: Female) from Kansas’ census data in the year 2022.\n\n#Necessary Packages\nlibrary(tidyverse)\nlibrary(ggplot2)\n\nTo demonstrate the use of the functions created, we are going to grab a small demo set to use these functions on.\n\nkansas_data &lt;- census(\n  year = 2022,\n  num_var = c(\"AGEP\", \"JWMNP\"),\n  cat_var = \"SEX\",\n  geog = \"state\",\n  spec = \"20\"\n)\n\nclass(kansas_data)\n\n[1] \"census\"     \"tbl_df\"     \"tbl\"        \"data.frame\"\n\nhead(kansas_data)\n\n# A tibble: 6 × 5\n   AGEP JWMNP PWGTP SEX   state\n  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;\n1    17     1     3 2     20   \n2    17     0    12 1     20   \n3    21     0    73 2     20   \n4    22     5    44 1     20   \n5    67     0    58 2     20   \n6    75     0     9 1     20   \n\n\nWe are going to use the created summary function to summarize all the numeric columns except for PWGTP to get a named list. It is a numeric table of weighted means/standard deviations (excluding PWGTP) and a categorical table of the weighted counts. By default it summarizes are the numeric columns in the tibble but we can select specific columns when we want to trim our focus.\n\n#Numeric (except for PWGTP)\noutput &lt;- summary.census(census_data)\nhead(output$numeric)\n\n  variable weighted_mean weighted_sd\n1     AGEP      38.69239    23.57071\n\nhead(output$categorical)\n\n  variable level weighted_count\n1      SEX     1        1470818\n2      SEX     2        1466332\n3    state    20        2937150\n\n#Specific Numerical Summary\nAGEP_Specific &lt;- summary.census(census_data, num_var = \"AGEP\", cat_var = \"SEX\")\nAGEP_Specific$numeric\n\n  variable weighted_mean weighted_sd\n1     AGEP      38.69239    23.57071\n\n\nFor visual representation, we use a created plot function which will always produce a boxplot. The variables are passed as strings using named arguments. The plot function below uses SEX as the categorical variable and AGEP as the numeric variable.\n\nplot(census_data, \"SEX\", \"AGEP\")\n\n\n\n\n\n\n\n\nThe summaries and plots above investigated census data from the state of Kansas (code 20) in the year 2022 with the variables of interest being AGEP (age) and SEX (1: Male, 2: Female). The boxplot tells us that the age distributions for males and females are pretty similar. However there do appear to be two slight differences. The medians are pretty close together with Females having a slightly higher median than Males. That along with the fact that the upper quartile for females is slightly larger than its own lower quartile indicates that there are more older women in the population in Kansas (slight skew in population) which does not appear present for the men."
  },
  {
    "objectID": "Function Code.html",
    "href": "Function Code.html",
    "title": "Functions",
    "section": "",
    "text": "Writing a function to input an API Url and then review it in our workspace. The timeout was increased to allow for the heavier burdens that come with loading the large datasets with the later functions on this page.\n\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   4.0.0     ✔ tibble    3.3.0\n✔ lubridate 1.9.4     ✔ tidyr     1.3.1\n✔ purrr     1.1.0     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\nlibrary(httr)\n\nusual_process &lt;- function(URL) {\n  id &lt;- GET(URL, httr::timeout(60))\n  return(id)\n}\n\nWriting a function to take in the output of returned by GET() and create a tibble from it, assigning column names relevant to the data of interest.\n\nlibrary(jsonlite)\n\n\nAttaching package: 'jsonlite'\n\n\nThe following object is masked from 'package:purrr':\n\n    flatten\n\nhelper &lt;- function(id) {\n  parsed_stats &lt;- fromJSON(rawToChar(id$content))\n  tibble &lt;- as_tibble(parsed_stats)\n  colnames(tibble) &lt;- tibble[1,]\n  tibble &lt;- tibble[-1,]\n  return(tibble)\n}\n\nWriting a function to query the Census API and also allow several variables to be specified within.\n\n#setting up function with default arguments\ncensus &lt;- function(year = 2022, num_var = c(\"AGEP\", \"PWGTP\"), cat_var = \"SEX\", geog = \"state\", spec = \"20\") {\n  \n  #checking for valid year\n  if(!(year %in% c(2010:2022))) {\n    stop(\"Error: year not valid\")\n  } \n  \n  #describing valid numeric variables\n  num_valid &lt;- c(\"AGEP\", \"GASP\", \"GRPIP\", \"JWAP\", \"JWDP\", \"JWMNP\", \"PWGTP\")\n  \n  #ensuring the PWGTP is always returned\n  num_var &lt;- unique(c(num_var, \"PWGTP\"))\n  \n  #checking for valid numeric variables, then cleaning it up to be easily added to url\n  if(any(!(num_var %in% num_valid))) {\n    stop(\"Error: num_var not valid\")\n  }\n  num_var &lt;- paste(num_var, collapse = \",\")\n  \n  #describing valid categorical variables\n  cat_valid &lt;- c(\"FER\", \"HHL\", \"HISPEED\", \"JWTRNS\", \"SCH\", \"SCHL\", \"SEX\")\n  \n  #checking for valid categorical variables\n  if(any(!(cat_var %in% cat_valid))) {\n    stop(\"Error: cat_var not valid\")\n  }\n  \n  #ensuring at least one catvar is returned, then cleaning variable up to be easily added to url\n  if(length(cat_var) == 0) {\n    stop(\"Error: at least one cat_var must be specified\")\n  }\n  cat_var &lt;- paste(cat_var, collapse = \",\")\n  \n  #checking for valid geographical levels & subsets depending on level selected, includes all of the given geography level if no subset is specified\n  spec_valid &lt;- list(region = 1:4, division = 1:9, state = 1:56)\n  if(is.null(spec)) {\n     \n  }\n    else {\n      if(!geog %in% names(spec_valid)) {\n    stop(\"Error: invalid geog\")\n  }\n  if(!spec %in% spec_valid[[geog]]) {\n    stop(\"Error: invalid spec for geog selected\")\n  }\n    }\n  \n  #creating url from various arguments for census api\n  url &lt;- paste0(\"https://api.census.gov/data/\", as.character(year), \"/acs/acs1/pums?get=\", num_var, \",\", cat_var, \"&for=\", geog)\n  if(length(spec) != 0) {\n    url &lt;- paste0(url, \":\", spec)\n  }\n  \n  #GET function from first problem\n  id &lt;- usual_process(url)\n  \n  #helper function from second problem to create tibble \n  tibble &lt;- helper(id)\n  \n  #writing a new function to parse out the number code  for time columns into a midpoint time value. the function relies on the fact that the midpoints of each number code: (0-285) start at 00:002 and count up by intervals of 5 minutes.\n convert_time &lt;- function(x) {\n   time_cols &lt;- c(\"JWAP\", \"JWDP\")\n   for(col in time_cols) {\n     if(col %in% names(x)) {\n       numeric_col &lt;- as.numeric(x[[col]])\n       x[[col]] &lt;- ifelse(numeric_col == 0, as.POSIXct(NA), as.POSIXct(\"00:02\", format = \"%H:%M\") + (numeric_col-1) * 300)\n       class(x[[col]]) &lt;- c(\"POSIXct\", \"POSIXt\")\n     }\n   }\n   return(x)\n }\n\n  #converts JWAP and JWDP code numbers to midpoint time, other variables in num_var to numeric\n  tibble &lt;- tibble |&gt; convert_time()\n  \n  tibble &lt;- tibble |&gt; mutate(across(any_of(c(\"AGEP\", \"GASP\", \"GRPIP\", \"JWMNP\", \"PWGTP\")), as.numeric))\n  \n  class(tibble) &lt;- c(\"census\", class(tibble))\n\n  return(tibble)\n}\n\nWriting a function that allows a user to specify all the parameters above as well as multiple years through looping the single year function above.\n\n#Setting up the function with same arguments from above, but with the addition of the years variable.\ncensus_year_range &lt;- function(years, num_var = c(\"AGEP\", \"PWGTP\"), cat_var = \"SEX\", geog = \"state\", spec = \"20\") {\n  \n  #creating a list to store results\n  output &lt;- list()\n  \n  #for loop to apply the census function to each year of interest, as well as transferring the arguments of census_year_range to the arguments of the census function\n  for(x in years) {\n    output[[as.character(x)]] &lt;- census(year = x, num_var = num_var, cat_var = cat_var, geog = geog, spec = spec)\n  }\n  \n  #binding the tibbles together with a years column\n  bind_rows(output, .id = \"years\")\n}"
  },
  {
    "objectID": "Function Code.html#data-processing",
    "href": "Function Code.html#data-processing",
    "title": "Functions",
    "section": "",
    "text": "Writing a function to input an API Url and then review it in our workspace. The timeout was increased to allow for the heavier burdens that come with loading the large datasets with the later functions on this page.\n\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   4.0.0     ✔ tibble    3.3.0\n✔ lubridate 1.9.4     ✔ tidyr     1.3.1\n✔ purrr     1.1.0     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\nlibrary(httr)\n\nusual_process &lt;- function(URL) {\n  id &lt;- GET(URL, httr::timeout(60))\n  return(id)\n}\n\nWriting a function to take in the output of returned by GET() and create a tibble from it, assigning column names relevant to the data of interest.\n\nlibrary(jsonlite)\n\n\nAttaching package: 'jsonlite'\n\n\nThe following object is masked from 'package:purrr':\n\n    flatten\n\nhelper &lt;- function(id) {\n  parsed_stats &lt;- fromJSON(rawToChar(id$content))\n  tibble &lt;- as_tibble(parsed_stats)\n  colnames(tibble) &lt;- tibble[1,]\n  tibble &lt;- tibble[-1,]\n  return(tibble)\n}\n\nWriting a function to query the Census API and also allow several variables to be specified within.\n\n#setting up function with default arguments\ncensus &lt;- function(year = 2022, num_var = c(\"AGEP\", \"PWGTP\"), cat_var = \"SEX\", geog = \"state\", spec = \"20\") {\n  \n  #checking for valid year\n  if(!(year %in% c(2010:2022))) {\n    stop(\"Error: year not valid\")\n  } \n  \n  #describing valid numeric variables\n  num_valid &lt;- c(\"AGEP\", \"GASP\", \"GRPIP\", \"JWAP\", \"JWDP\", \"JWMNP\", \"PWGTP\")\n  \n  #ensuring the PWGTP is always returned\n  num_var &lt;- unique(c(num_var, \"PWGTP\"))\n  \n  #checking for valid numeric variables, then cleaning it up to be easily added to url\n  if(any(!(num_var %in% num_valid))) {\n    stop(\"Error: num_var not valid\")\n  }\n  num_var &lt;- paste(num_var, collapse = \",\")\n  \n  #describing valid categorical variables\n  cat_valid &lt;- c(\"FER\", \"HHL\", \"HISPEED\", \"JWTRNS\", \"SCH\", \"SCHL\", \"SEX\")\n  \n  #checking for valid categorical variables\n  if(any(!(cat_var %in% cat_valid))) {\n    stop(\"Error: cat_var not valid\")\n  }\n  \n  #ensuring at least one catvar is returned, then cleaning variable up to be easily added to url\n  if(length(cat_var) == 0) {\n    stop(\"Error: at least one cat_var must be specified\")\n  }\n  cat_var &lt;- paste(cat_var, collapse = \",\")\n  \n  #checking for valid geographical levels & subsets depending on level selected, includes all of the given geography level if no subset is specified\n  spec_valid &lt;- list(region = 1:4, division = 1:9, state = 1:56)\n  if(is.null(spec)) {\n     \n  }\n    else {\n      if(!geog %in% names(spec_valid)) {\n    stop(\"Error: invalid geog\")\n  }\n  if(!spec %in% spec_valid[[geog]]) {\n    stop(\"Error: invalid spec for geog selected\")\n  }\n    }\n  \n  #creating url from various arguments for census api\n  url &lt;- paste0(\"https://api.census.gov/data/\", as.character(year), \"/acs/acs1/pums?get=\", num_var, \",\", cat_var, \"&for=\", geog)\n  if(length(spec) != 0) {\n    url &lt;- paste0(url, \":\", spec)\n  }\n  \n  #GET function from first problem\n  id &lt;- usual_process(url)\n  \n  #helper function from second problem to create tibble \n  tibble &lt;- helper(id)\n  \n  #writing a new function to parse out the number code  for time columns into a midpoint time value. the function relies on the fact that the midpoints of each number code: (0-285) start at 00:002 and count up by intervals of 5 minutes.\n convert_time &lt;- function(x) {\n   time_cols &lt;- c(\"JWAP\", \"JWDP\")\n   for(col in time_cols) {\n     if(col %in% names(x)) {\n       numeric_col &lt;- as.numeric(x[[col]])\n       x[[col]] &lt;- ifelse(numeric_col == 0, as.POSIXct(NA), as.POSIXct(\"00:02\", format = \"%H:%M\") + (numeric_col-1) * 300)\n       class(x[[col]]) &lt;- c(\"POSIXct\", \"POSIXt\")\n     }\n   }\n   return(x)\n }\n\n  #converts JWAP and JWDP code numbers to midpoint time, other variables in num_var to numeric\n  tibble &lt;- tibble |&gt; convert_time()\n  \n  tibble &lt;- tibble |&gt; mutate(across(any_of(c(\"AGEP\", \"GASP\", \"GRPIP\", \"JWMNP\", \"PWGTP\")), as.numeric))\n  \n  class(tibble) &lt;- c(\"census\", class(tibble))\n\n  return(tibble)\n}\n\nWriting a function that allows a user to specify all the parameters above as well as multiple years through looping the single year function above.\n\n#Setting up the function with same arguments from above, but with the addition of the years variable.\ncensus_year_range &lt;- function(years, num_var = c(\"AGEP\", \"PWGTP\"), cat_var = \"SEX\", geog = \"state\", spec = \"20\") {\n  \n  #creating a list to store results\n  output &lt;- list()\n  \n  #for loop to apply the census function to each year of interest, as well as transferring the arguments of census_year_range to the arguments of the census function\n  for(x in years) {\n    output[[as.character(x)]] &lt;- census(year = x, num_var = num_var, cat_var = cat_var, geog = geog, spec = spec)\n  }\n  \n  #binding the tibbles together with a years column\n  bind_rows(output, .id = \"years\")\n}"
  },
  {
    "objectID": "Function Code.html#summary-functionsplots",
    "href": "Function Code.html#summary-functionsplots",
    "title": "Functions",
    "section": "Summary Functions/Plots",
    "text": "Summary Functions/Plots\nCreating the census summary function that will produce means and standard deviations for numeric variables as well as counts for categorical variables.\n\n#Calling data for function\ncensus_data &lt;- census()\n\nWarning: The `x` argument of `as_tibble.matrix()` must have unique column names if\n`.name_repair` is omitted as of tibble 2.0.0.\nℹ Using compatibility `.name_repair`.\n\nsummary.census &lt;- function(census_data, num_var = NULL, cat_var = NULL, na.rm = TRUE, ...){\n  #Checking for census class\n  if (!\"census\" %in% class(census_data)) {\n    stop(\"Error: Does not have census class\")\n  }\n  \n  #Checking that PWGTP exists and is numeric\n  if (!(\"PWGTP\" %in% names(census_data)) || !is.numeric(census_data$PWGTP)) {\n    stop(\"Error: PWGTP is either missing or not numeric\")\n  }\n  \n  #Creating weight vector\n  weight_vector &lt;- census_data$PWGTP\n  \n  #Defining numeric variable (user-selection)\n  if (is.null(num_var)) {\n    \n    #Default (all numeric colums besides PWGTP)\n    num_vars &lt;- names(dplyr::select(census_data, where(is.numeric)))\n    num_vars &lt;- num_vars[num_vars != \"PWGTP\"]\n    \n    if (length(num_vars) == 0) {\n      stop(\"Error: NOT a numeric variable\")\n    }\n    \n  } else {\n  \n    #Numeric Variables specificed by user \n    \n    #If the variables are not found\n    if (!all(num_var %in% names(census_data))) {\n      stop(\"Error: 1 or more user-provided numeric variables were NOT found\")\n    }\n    \n    #If the variables are not numeric\n    if (!all(sapply(census_data[num_var], is.numeric))) {\n      stop(\"Error: 1 or more user-provided variables is NOT numeric\")\n    }\n    \n    #If the input makes it  all the above checks then use\n    num_vars &lt;- num_var\n  }\n  \n  #Defining categorical variables (user-selection)\n  if (is.null(cat_var)) {\n    cat_vars &lt;- names(dplyr::select(census_data, where(is.character)))\n    \n    if (length(cat_vars) == 0) {\n      stop(\"Error: NOT a character variable\")\n    }\n    \n  } else {\n    \n    #Categorical variables specified by user\n    \n    #If categorical variables are not found\n    if (!all(cat_var %in% names(census_data))) {\n      stop(\"Error: 1 or more user-provided categorical variables were NOT found\")\n    }\n    #If variables are not character\n    if (!all(sapply(census_data[cat_var], is.character))) {\n      stop(\"Error: 1 or more user-provided categorical variables is NOT character\")\n    }\n    #If the input makes it  all the above checks then use\n    cat_vars &lt;- cat_var\n  }\n  \n  #Summary function definiton (A. Numeric Summaries B. Categorical Summaries)\n  \n  #Creating the Numeric Summary Table to hold the results\n  num_stats &lt;- data.frame(\n    variable = character(),\n    weighted_mean = numeric(),\n    weighted_sd = numeric(),\n    stringsAsFactors = FALSE\n    )\n  #Going through individual numeric variables\n  for (var in num_vars) {\n    numeric_vector &lt;- census_data[[var]]\n    \n    #Formulas\n    sample_mean &lt;- sum(numeric_vector * weight_vector)/ sum(weight_vector)\n    sample_sd &lt;- sqrt(sum(numeric_vector^2 * weight_vector) / sum(weight_vector)-sample_mean^2)\n    \n    #Adding row to the result table\n    num_stats &lt;- rbind(\n      num_stats,\n      data.frame(\n        variable = var,\n        weighted_mean = sample_mean,\n        weighted_sd = sample_sd,\n        stringsAsFactors = FALSE\n      )\n    )\n  }\n   #Creating the Categorical Summary Table to hold the results\n  cat_stats &lt;- data.frame(\n    variable = character(),\n    level = character(),\n    weighted_count = numeric(),\n    stringsAsFactors = FALSE\n  )\n  #Going through individual categorical variables\n  for (var in cat_vars) {\n    cat_tibble &lt;- census_data[[var]]\n    \n    #Weighted Counts\n    w_counts &lt;- tapply(weight_vector, cat_tibble, sum, na.rm = TRUE)\n    \n    #Making it a data frame \n    cat_df &lt;- data.frame(\n      variable = var,\n      level = names(w_counts),\n      weighted_count = as.numeric(w_counts),\n      stringsAsFactors = FALSE\n    )\n    #Adding the rows to the result table\n    cat_stats &lt;- rbind(cat_stats, cat_df)\n    \n  }\n  \n  #Returning Results \n  return(list(numeric = num_stats, categorical = cat_stats))\n  \n}\n\nTesting the summary function on a variable returned from the census API function.\n\n#Testing the summary function\nsummary.census(census_data)\n\n$numeric\n  variable weighted_mean weighted_sd\n1     AGEP      38.69239    23.57071\n\n$categorical\n  variable level weighted_count\n1      SEX     1        1470818\n2      SEX     2        1466332\n3    state    20        2937150\n\n\nCreating a generic plot function to visualize data in census tibbles.\n\n#Plot function\nplot &lt;- function(census_data, cat_var, num_var, ...) {\n  #Check that census_data is a census tibble\n  if (!\"census\" %in% class(census_data)) {\n    stop(\"Error: Object is not part of the census class\")\n  }\n  \n  #Checking variable existance\n  if (!cat_var %in% names(census_data)) {\n    stop(\"Error: Categorical variable not found\")\n  }\n  \n  if (!num_var %in% names(census_data)) {\n    stop(\"Error: Numeric variable not found\")\n  }\n\n#Making the boxplot\nlibrary(ggplot2)\nggplot(census_data,\n       aes(x = get(cat_var), y = get(num_var), weight = PWGTP)) + geom_boxplot() + xlab(\"SEX\") + ylab (\"AGEP\")\n}\n\nplot(census_data, \"SEX\", \"AGEP\")"
  }
]